<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<link rel="stylesheet" type="text/css" href="primmestyle.css" />
<title>PRIMME: PReconditioned Iterative MultiMethod Eigensolver</title>
</head>
<body>
<center>
<hr align="center" width="75%">
<h3>        PRIMME: PReconditioned Iterative MultiMethod Eigensolver
	<br>
      Copyright &copy 2005  Andreas Stathopoulos, James R. McCombs
	<br>
</h3>
<hr align="center" width="75%">
</center>
 
<table>
<tr><th class="tocheader">Table Of Contents</th></tr>
<tr><td class="Tregular">General Information</td></tr>
<tr><td class="Tregular_left"><a href="#license">License Information</a></td></tr>
<tr><td class="Tregular_left"><a href="#contact">Contact Information</a></td></tr>
<tr><td class="Tregular_left"><a href="#purpose">Purpose</a></td></tr>
<tr><td class="Tregular_left"><a href="#cite">Citing this Code</a></td></tr>
<tr><td class="Tregular">Installing</td></tr>
<tr><td class="Tregular_left"><a href="#directory">Directory Structure</a></td></tr>
<tr><td class="Tregular_left"><a href="#making">Making and Linking</a></td></tr>
<tr><td class="Tregular">Using the Library</td></tr>
<tr><td class="Tregular_left"><a href="#clibrary">C Library Interface</a></td></tr>
<tr><td class="Tregular_left_2"><a href="#running">Running</a></td></tr>
<tr><td class="Tregular_left_2"><a href="#paramSetting">Parameter Setting</a></td></tr>
<tr><td class="Tregular_left_3"><a href="#basicparams">Required Parameter Setting</a></td></tr>
<tr><td class="Tregular_left_3"><a href="#preset">Preset Method Setting</a></td></tr>
<tr><td class="Tregular_left_3"><a href="#display">Displaying parameters</a></td></tr>
<tr><td class="Tregular_left_3"><a href="#primme">The entire Primme Parameter Structure</a></td></tr>
<tr><td class="Tregular_left_3"><a href="#custom">Customized Parameter Setting</a></td></tr>
<tr><td class="Tregular_left"><a href="#fortran">Fortran Library Interface</a></td></tr>
<tr><td class="Tregular_left_2"><a href="#fortranrunning">Running from Fortran</a></td></tr>
<tr><td class="Tregular">Error Codes</td></tr>
<tr><td class="Tregular_left"><a href="#errors">Error Codes returned by dprimme/zprimme</a></td></tr>
</table>

<a name="license"></a>
<hr align="left" width="75%">
<h3>License Information</h3>
<hr align="left" width="75%">
<p class="twenty_five">
   This file is part of PRIMME.
</p>
<p class="twenty_five">
   PRIMME is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.
</p>
<p  class="twenty_five">
   PRIMME is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.
</p>
<p class="twenty_five">
   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, write to the Free Software
   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
</p>
<p class="breakhere"></p>

<a name="contact"></a>
<hr align="left" width="75%">
<h3>Contact Information (reporting bugs or questions about functionality)</h3>
<hr align="left" width="75%">
<p class="normal">
<table>
<tr><td class="regular">Andreas Stathopoulos</td><td></td></tr>
<tr><td class="regular">College of William and Mary</td><td class="regular_left">E-mail: andreas@cs.wm.edu</td></tr>
<tr><td class="regular">Department of Computer Science</td><td class="regular_left">Phone:  757-221-3483</td></tr>
<tr><td class="regular">P.O. Box 8795</td><td class="regular_left">Fax:    757-221-1717</td></tr>
<tr><td class="regular">Williamsburg, VA 23187-8795</td><td class="regular_left">http://www.cs.wm.edu/~andreas</td></tr>
</table>
</p>


<a name="purpose"></a>
<hr align="left" width="75%">
<h3>Purpose</h3>
<hr align="left" width="75%">
<p class="zero">
PRIMME Version 1.2   (December 21, 2014)</p>

<p class="twenty_five">
Finds a number of eigenvalues and their corresponding eigenvectors of a 
real symmetric, or complex hermitian matrix A. Largest, smallest and interior 
eigenvalues are supported. Preconditioning can be used to accelarate 
convergence. 
</p>
<p class="twenty_five">
PRIMME is written in C, but a complete Fortran77 interface is also provided.
</p>
<p class="twenty_five">
Pronounced as "prime"
</p>

<a name="cite"></a>
<hr align="left" width="75%">
<h3>How to cite this code</h3>
<hr align="left" width="75%">

<p class="twenty_five">
To cite PRIMME, please cite paper [1]. <br>
More information on the algorithms and research that led to this software
can be found in the rest of the papers.
The work has been supported by a number of grants from the
National Science Foundation.
</p>

<p class="normal">
<table cellpadding=3>
<tr><td class="regular">[1]</td><td class="regularW">  A. Stathopoulos and J. R. McCombs
        PRIMME: PReconditioned Iterative MultiMethod Eigensolver: Methods and software description,
        ACM Transaction on Mathematical Software Vol. 37, No. 2, (2010), 21:1--21:30.
</td></tr>
<tr><td class="regular">[2]</td><td class="regularW">  A. Stathopoulos, Nearly optimal preconditioned methods for hermitian 
     eigenproblems under limited memory. Part I: Seeking one eigenvalue,
        SIAM J. Sci. Comput., Vol. 29, No. 2, (2007), 481--514.
</td></tr>
<tr><td class="regular">[3]</td><td class="regularW">  A. Stathopoulos and J. R. McCombs, 
	Nearly optimal preconditioned methods for hermitian eigenproblems under limited memory. 
	Part II: Seeking many eigenvalues, 
        SIAM J. Sci. Comput., Vol. 29, No. 5, (2007), 2162-2188.
</td></tr>
<tr><td class="regular">[4]</td><td class="regularW">  J. R. McCombs and A. Stathopoulos, Iterative Validation of Eigensolvers:
     A Scheme for Improving the Reliability of Hermitian Eigenvalue Solvers
        SIAM J. Sci. Comput.,   Vol. 28, No. 6, (2006), 2337--2358.
</td></tr>
<tr><td class="regular">[5]</td><td class="regularW">  A. Stathopoulos, Locking issues for finding a large number of 
eigenvectors
     of hermitian matrices, Tech Report: WM-CS-2005-03, July, 2005.</td></tr>
</table>
</p>

<p class="breakhere"></p>

<a name="directory"></a>
<hr align="left" width="75%">
<h3>Directory structure </h3>
<hr align="left" width="75%">

<p class="zero">
PRIMME/
</p>

<table cellpadding=3>
<tr><td class="regular">COPYING.txt</td><td class="left"><- LGPL License</td></tr>
<tr><td class="regular">Make_flags</td><td class="left"><- flags to be used by makefiles to compile library and tests</td></tr>
<tr><td class="regular">Link_flags</td><td class="left"><- flags needed in making and linking the test programs</td></tr>
<tr><td class="regular">PRIMMESRC/</td><td class="left"><- Directory with source code in the following subdirectories:</td></tr>
<tr><td class="regular_left">COMMONSRC/</td><td class="left"><- Interface and common functions used by all precision versions</td></tr>
<tr><td class="regular_left">DSRC/</td><td class="left"><- The source code for the double precision dprimme</td></tr>
<tr><td class="regular_left">ZSRC/</td><td class="left"><- The source code for the double complex precision zprimme</td></tr>
<tr><td class="regular">DTEST/</td><td class="left"><- dprimme sample C and F77 drivers, both seq and parallel </td></tr>
<tr><td class="regular">ZTEST/</td><td class="left"><- zprimme sample C and F77 drivers, sequential only</td></tr>
<tr><td class="regular">libprimme.a</td><td class="left"><- The PRIMME library (to be made)</td></tr>
<tr><td class="regular">makefile</td><td class="left"><- makes the libraries, and the sequential/parallel tests</td></tr>
<tr><td class="regular">readme.html</td><td class="left"><- this file</td></tr>
<tr><td class="regular">primmestyle.css</td><td class="left"><- an html style file</td></tr>
<tr><td class="regular">readme.txt</td><td class="left"><- this file in text format</td></tr>
<tr><td class="regular">doc.pdf</td><td class="left"><- a printable version of this file </td></tr>
</table>

<br>
<a name="making"></a>
<hr align="left" width="75%">
<h3>Making & Linking</h3>
<hr align="left" width="75%">
<p class="zero">
Users must customize Make_flags to create the library.<br> 
Users may customize Link_flags to create the test programs.<br><br></p>
<table>
<tr><td class="regular">Make_flags:</td><td class="leftW">
  has the flags and compilers used by the makefiles in PRIMMESRC 
  to make the libprimme.a library (or the stand alone double or complex 
  precision libraries, libdprimme.a, libzprimme.a). Make_flags is also used 
  in DTEST, ZTEST dirs to build the sequential test executables.
  The parallel test is built with DTEST/Makefile_par using flags and compilers 
  for parallelism.</td></tr>
  <tr><td></td><td class="leftW">At minimum, the user must specify the path where the PRIMME dir is located.</td></tr>
  <tr><td></td><td class="leftW">PRIMME uses the UNIX gettimeofday() utility. If not available,
	modify the &nbsp;<a href="PRIMMESRC/COMMONSRC/wtime.c">PRIMMESRC/COMMONSRC/wtime.c</a> </td></tr>
</table>

<table>
<tr><td class="regular">Link_flags: </td><td class="leftW">
has paths for external libraries and linking loaders needed to 
  link the executables of the test programs. To run PRIMME:</td></tr>
  <tr><td></td><td class="leftW"> <em>BLAS and LAPACK libraries should be available</em> </td></tr>
  <tr><td></td><td class="leftW"> <em>Users must include primme.h in their C programs, or primme_f77.h in 
      their fortran programs. For the double complex data struct see Complex.h.</em></td></tr>
  <tr><td></td><td class="leftW">These header files are located in <a 
href="PRIMMESRC/COMMONSRC/">PRIMMESRC/COMMONSRC/</a></td></tr>
</table>

<p class="zero">
makefile can perform the following functions:</p>

<table>
<tr><td class="regular">make all</td><td class="regular_left">builds: lib depends seqs pars</td></tr>
<tr><td class="regular_left">make lib</td><td class="regular_left">builds libprimme.a in PRIMME/. Alternatively:</td></tr>
<tr><td class="regular_left">make libd</td><td class="regular_left">if only dprimme is of interest build libdprimme.a</td></tr>
<tr><td class="regular_left">make libz</td><td class="regular_left">if only zprimme is of interest build libzprimme.a</td></tr>
<tr><td class="regular_left">make depends</td><td class="regular_left">builds the dependencies files in (D)ZTEST/</td></tr>
<tr><td class="regular_left_2">make ddepends_seq</td><td class="regular_left">builds only the ddependencies_seq in DTEST</td></tr>
<tr><td class="regular_left_2">make zdepends_seq</td><td class="regular_left">builds only the zdependencies_seq in ZTEST</td></tr>
<tr><td class="regular_left_2">make ddepends_par</td><td class="regular_left">builds only the ddependencies_par in DTEST</td></tr>
<tr><td class="regular_left">make seqs</td><td class="regular_left">builds all sequential executables in (D)ZTEST</td></tr>
<tr><td class="regular_left_2">make seq_dprimme</td><td class="regular_left">builds only the seq real C executable in DTEST</td></tr>
<tr><td class="regular_left_2">make seqf77_dprimme</td><td class="regular_left">builds only the seq real F77 executable in DTEST</td></tr>
<tr><td class="regular_left_2">make seq_zprimme</td><td class="regular_left">builds only the seq herm C executable in ZTEST</td></tr>
<tr><td class="regular_left_2">make seqf77_zprimme</td><td class="regular_left">builds only the seq herm F77 executable in ZTEST</td></tr>
<tr><td class="regular_left">make pars</td><td class="regular_left">builds all the parallel executables in DTEST</td></tr>
<tr><td class="regular_left_2">make par_dprimme</td><td class="regular_left">currently the only parallel C executable in DTEST</td></tr>
<tr><td class="regular">make clean</td><td class="regular_left">removes all *.o, a.out, and core files from all dirs</td></tr>
<tr><td class="regular_left">make backup</td><td class="regular_left">makes a tar.gz dated archive of entire PRIMME directory</td></tr>
</table>

<p class="twenty_five">
The dependencies in (D)ZTEST need not be built unless the test code has changed,
or the d/zdependencies_* files have been deleted. 
</p>
<p class="twenty_five">
The sequential and parallel versions of d/zprimme (the front-ends to PRIMME)
are the same, compiled with any sequential compiler. Parallel programs
can just link with and call dprimme (see below).
</p>
<p class="twenty_five">
In <b>DTEST/</b><br>
The <a href="DTEST/driver_seq.c">driver_seq.c</a> is the driver for the sequential test. It fairly well 
structured and reads all or any of the parameters from two configuration files.
It should be the best starting point. <a href="DTEST/Makefile_seq">Makefile_seq</a> is used for this.<br><br>
 The provided sample preconditioner and matvec are from SPARSKIT:<br>
   See <a href="http://www-users.cs.umn.edu/~saad/software/SPARSKIT/sparskit.html">http://www-users.cs.umn.edu/~saad/software/SPARSKIT/sparskit.html</a>
</p>
<p class="twenty_five">
The <a href="DTEST/driver_par.c">driver_par.c</a> is the driver for the parallel test. It follows closely the 
structure of <a href="DTEST/driver_seq.c">driver_seq.c</a>. It uses MPI for communication and performs matrix-
vector multiplications and Sparse Approximate Inverse preconditioning using 
the ParaSails library. <a href="DTEST/Makefile_par">Makefile_par</a> specifies parallel compilation/linking.
<br><br>
ParaSails can be downloaded from:
   <a href="http://computation.llnl.gov/casc/parasails">http://computation.llnl.gov/casc/parasails</a>
</p>
<p class="twenty_five">
The <a href="DTEST/driver_f77seq.f">driver_f77seq.f</a> is a sample f77 program made with <a 
href="DTEST/Makefile_f77seq">Makefile_f77seq</a>.
It calls the Fortran interface provided by PRIMME. This interface includes 
a set of wrapper functions that are callable from Fortran to manipulate the 
structure and evoke the eigensolver. For a description of the F77 interface 
see at the end of this file.
</p>
<p class="twenty_five">
In <b>ZTEST/</b><br>
We provide <a href="ZTEST/driver_seq.c">driver_seq.c</a> and <a href="ZTEST/driver_f77seq.f">driver_f77seq.f</a> as in 
the real case, 
with <a href="ZTEST/Makefile_seq">Makefile_seq</a> and <a href="ZTEST/Makefile_f77seq">Makefile_f77seq</a> 
respectively. Two different diagonal 
preconditioners can be used, but no ILUT or Parasails.
</p>

	<hr align="center" width="50%" size="1%">
	<center>
	<p class="emphasis">The comments in the sample drivers show how to run executables.</p>
	<p class="emphasis"> Note: these sample drivers are meant to be expository and not high performance.</p>
	</center>
	<hr align="center" width="50%" size="1%">
<br>

<a name="systems"></a>
<hr align="left" width="75%">
<h3>Systems where the code has been tested</h3>
<hr align="left" width="75%">

  Primary development with GNU gcc, g++, and gfortran (Versions 4.2 and later) <br>
  Many users have reported builds on several other platforms/compilers <br> <br>

  Compatible with LP64 BLAS and LAPACK libraries. <br>
  ILP64 possible with other compilers but not tested. <br> <br>

<table>
<tr><td class="regular">SUSE Linux 2.6.13-15.12-smp SMP (64 bit) dual core, dual Intel Xeon 3.73GHz</td></tr>
<tr><td class="regular">SUSE Linux 2.6.13-15.12-default (32 bit) Intel Pentium 4, 2.40GHz</td></tr>
<tr><td class="regular">CentOS Linux 2.6.9-22.ELsmp (64 bit) dual processor AMD Opteron 250</td></tr>
<tr><td class="regular">SunOS 5.9, quad processor Sun-Fire-280R, and several other UltraSparcs</td></tr>
<tr><td class="regular">AIX 5.2 IBM SP POWER 3+, 16-way SMP, 375 MHz nodes (seaborg at nersc.gov)</td></tr>
<tr><td class="regular">Darwin Kernel Version 8.8.0 PowerPC dual Mac G5, 2 GHz</td></tr>
<tr><td class="regular">Darwin Kernel Version 8.8.0 PowerPC Mac G4, 1.67 GHz</td></tr>
<tr><td class="regular">Macbook Pro, Intel i7, Darwin Kernel Version 12.5.0, 2.6 GHz </td></tr>
</table>
<br>

<p class="breakhere"></p>
<a name="clibrary"></a>
<hr align="left" width="75%">
<h3>C Library Interface</h3>
<hr align="left" width="75%">
<p class="zero">
To solve real symmetric standard eigenproblems call:</p>
<p class="courier">int dprimme(double *evals, double *evecs, double *resNorms, 
		primme_params *primme);</p>
<p class="zero">To solve hermitian standard eigenproblems call:</p>
<p class="courier">int zprimme(double *evals, Complex_Z *evecs, double *resNorms, 
		primme_params *primme);</p>

<p class="zero">The following interface functions are available in &nbsp;<a 
href="PRIMMESRC/COMMONSRC/primme_interface.c">PRIMMESRC/COMMONSRC/primme_interface.c</a></p>
<p class="courier">void primme_initialize(primme_params *primme);</p>
<p class="courier">int primme_set_method(primme_preset_method method, primme_params *params);</p>
<p class="courier">void primme_display_params(primme_params primme);</p>
<p class="courier">void *primme_calloc(size_t nelem, size_t elsize, const char *target);</p>
<p class="courier">void *primme_valloc(size_t numBytes, const char *target);</p>
<p class="courier">void primme_Free(primme_params primme);</p>

<p class="zero">To view the primme data structure <a href="#primme">click here</a>.</p>

<br>
The following data type is used internally for double complex
	(available in <a href="PRIMMESRC/COMMONSRC/Complex.h">PRIMMESRC/COMMONSRC/Complex.h</a>):
<table><tr><td class="regular_courier">
typedef struct {</td></tr>
<tr><td class="courier_left">         double r, i;</td></tr>
<tr><td class="regular_courier">} Complex_Z;</td></tr>
</table>
<br>

<a name="running"></a>
<hr align="left" width="75%">
<h3>Running</h3>
<hr align="left" width="75%">
<p class="zero">
To call dprimme follow the basic steps below (look also
at &nbsp;<a href="DTEST/driver_seq.c">DTEST/driver_seq.c</a>).
</p>
<ul>
<li> Include: <p class="courier">#include "primme.h"</p>
<li><p class="zero">Initialize a primme structure for default settings:
<br>
   <p class="courier">primme_params primme;</p>
   <p class="courier">primme_initialize(&amp;primme);</p>
<li><p class="zero">Then, for a given eigenproblem, set one of the 
	<a href="#preset">preset methods </a>:
<p class="courier">ret = primme_set_method(method, &amp;primme);</p>
	or/and set some of the various structure members manually 
	(see below and <a href="PRIMMESRC/COMMONSRC/primme.h">PRIMMESRC/COMMONSRC/primme.h</a>)</p>

<li><p class="zero">Then call dprimme:</p>
   <p class="courier">ret = dprimme(evals, evecs, rnorms, &amp;primme);</p>

<table>
<tr><td class="regular_courier">evals</td><td class="regular_left">a double array of size primme.numEvals</td><td class="regular_left">OUTPUT</td></tr>
<tr><td class="regular_courier">evecs</td><td class="regular_left">a double array of size primme.nLocal*primme.n</td><td class="regular_left">INPUT / OUTPUT</td></tr>
<tr><td class="regular_courier">rNorms</td><td class="regular_left">a double array of size primme.numEvals</td><td class="regular_left">OUTPUT</td></tr>
<tr><td class="regular_courier">primme</td><td class="regular_left">the above struct. Some members return values</td><td class="regular_left">INPUT / OUTPUT</td></tr>
<tr><td class="regular_courier">ret</td><td class="regular_left">error return code</td><td class="regular_left">OUTPUT</td></tr>
</table>

<li><p class="zero">Before exiting or running primme again free the work arrays in primme:</p>
   <p class="courier"> primme_Free(&amp;primme);</p>
</ul>


<a name="paramSetting"></a>
<a name="basicparams"></a>
<hr align="left" width="75%">
<h3>Required parameter setting </h3>
<hr align="left" width="75%">
<p class="zero">
PRIMME requires the user to set at least the following members of the primme 
struct, as they define the problem to be solved:
</p>

<table align=center>
<tr><td class="courier">n      			(the dimension of the matrix)</td></tr>
<tr><td class="courier">nLocal 			(only if it is parallel program)</td></tr>
<tr><td class="courier">void (*matrixMatvec)</td></tr>
<tr><td class="courier">&nbsp;&nbsp;(void *x, void *y, int *blockSize, struct primme_params *primme);</td></tr>
</table>
<p class="zero">
In addition, most users would want to specify how many eigenpairs to find, 
and provide a preconditioner (if available), a mass matrix matvec function 
(if a generalized eigenproblem), and a globalSum operation (if parallel).
</p>

<table align=center>
<tr><td class="courier">numEvals</td></tr>
<tr><td class="courier">void (*applyPreconditioner)</td></tr>
<tr><td class="courier">&nbsp;&nbsp;(void *x, void *y, int *blockSize, struct primme_params *primme);</td></tr>
<tr><td class="courier">void (*massMatrixMatvec)</td></tr>
<tr><td class="courier">&nbsp;&nbsp;(void *x, void *y, int *blockSize, struct primme_params *primme);</td></tr>
<tr><td class="courier">void (*globalSumDouble)		(only if it is parallel program)</td></tr>
<tr><td class="courier">&nbsp;&nbsp;(void *sendBuf, void *recvBuf, int *count, primme_params *primme);</td></tr>
</table>
<p class="zero">
It is useful to have set all these before calling primme_set_method. 
Also, if users have a preference on basisSize, blockSize, etc, they should 
also provide them into primme prior to the <font face="courier">primme_set_method()</font> call.
This helps primme_set_method make the right choice on other parameters.
</p>


<a name="preset"></a>
<hr align="left" width="75%">
<h3>Preset parameter setting </h3>
<hr align="left" width="75%">
<p class="zero">
To use one of the default methods call:</p>
<p class="courier">ret = primme_set_method(method, &amp;primme);</p>
<p class="zero">
with method one of the following: </p>
<p class="courier">primme_preset_method method;</p>

<table>
<tr><td class="courier">typedef enum {</td><td></td><td></td></tr>
<tr><td class="courier">DYNAMIC,</td><td class="regular_left">// Switches to the best method dynamically</td></tr>
<tr><td class="courier">DEFAULT_MIN_TIME,</td><td class="regular_left">// Currently set as JDQMR_ETol</td></tr>
<tr><td class="courier">DEFAULT_MIN_MATVECS,</td><td class="regular_left"> // Currently set as GD_Olsen_plusK</td></tr>
<tr><td class="courier">Arnoldi,</td><td class="regular_left">// Anoldi implemented a la Generalized Davidson</td></tr>
<tr><td class="courier">GD,</td><td class="regular_left"> // Generalized Davidson</td></tr>
<tr><td class="courier">GD_plusK,</td><td class="regular_left">// GD+k with locally optimal restarting for k evals</td></tr>
<tr><td class="courier">GD_Olsen_plusK,</td><td class="regular_left">// GD+k, preconditioner applied to (r+deltaeps*x)</td></tr>
<tr><td class="courier">JD_Olsen_plusK,</td><td class="regular_left">// As above, only deltaeps computed as in JD</td></tr>
<tr><td class="courier">RQI,</td><td class="regular_left">// (accelerated) Rayleigh Quotient Iteration</td></tr>
<tr><td class="courier">JDQR,</td><td class="regular_left">// Jacobi-Davidson with const number of inner steps</td></tr>
<tr><td class="courier">JDQMR,</td><td class="regular_left">// JDQMR adaptive stopping criterion for inner QMR</td></tr>
<tr><td class="courier">JDQMR_ETol,</td><td class="regular_left">// JDQMR + stops after resid reduces by a 0.1 factor</td></tr>
<tr><td class="courier">SUBSPACE_ITERATION,</td><td class="regular_left">// Subspace iteration</td></tr>
<tr><td class="courier">LOBPCG_OrthoBasis,</td><td class="regular_left">// LOBPCG with orthogonal basis. maxBlockSize = numEvals</td></tr>
<tr><td class="courier">LOBPCG_OrthoBasis_Window</td><td class="regular_left">// LOBPCG with sliding window of maxBlockSize< numEvals </td></tr>
<tr><td class="courier">} primme_preset_method;</td><td></td><td></td></tr>
</table>

<p class="zero">
In the absense of preset values in the primme structure, primme_set_method() 
uses expertly tuned default values for all parameters so that users can set 
a method with minimum or no input. </p>

<p class="zero">
Users can control any parameter before or after calling primme_set_method().
<ul>
<li>Example: if primme.maxBasisSize is set before calling primme_set_method(),<br>
other parameters (restart size, maximum block size) are computed accordingly.
<li>Example: Only primme.maxBlockSize and primme.numEvals need be set before calling <br>
LOBPCG_OrthoBasis_Window, and only primme.numEvals if calling LOBPCG_OrthoBasis.
<li>Example: Expert users may decide to modify some choices made by primme_set_method(), 
	<br> e.g., increasing the maxBasisSize afterwards and before calling (z)dprimme().
</ul>
</p>

<p class="zero">
See <font face="courier">primme_set_method</font> in <a 
href="PRIMMESRC/COMMONSRC/primme_interface.c">PRIMMESRC/COMMONSRC/primme_interface.c</a> for exact description 
of
how each method sets the members of the primme structure. 
</p>


<a name="display"></a>
<hr align="left" width="75%">
<h3>Displaying the primme configuration</h3>
<hr align="left" width="75%">

<p class="zero">
The user can call
</p> 
<p class="courier">
	primme_display_params(primme);
</p>
<p class="zero">to display all the settings of primme variables. This is done in a format 
similar to the input format required by our (D)ZTEST drivers.
Note that in some cases, a couple of primme variables may change internally 
in <font face="courier">dprimme()</font>. Calling <font face="courier">primme_display_params()</font> after 
<font face="courier">dprimme()</font> shows 
the actual values used.</p>
<br>

<p class="breakhere"></p>

<a name="primme"></a>
<hr align="left" width="75%">
<h3>Primme_params structure</h3>
<hr align="left" width="75%">

<table>
<tr><td colspan=2 class="regular_courier">typedef struct primme_params {</td></tr>
<tr><td colspan=2 class="courier_left">    // The user must input at least the following two arguments</td></tr>
<tr><td colspan=2 class="courier_left">    <a class="code" href="#cintn">int n;</a></td></tr>
<tr><td colspan=2 class="courier_left">    <a class="code" href="#matrixmatvec"">void (*matrixMatvec)<br>
 &nbsp;&nbsp;( void *x,  void *y, int *blockSize, struct primme_params  *primme);</a></td></tr>
<tr><td colspan=2>&nbsp;</td></tr>
<tr><td colspan=2 class="courier_left">    // Preconditioner applied on block of vectors (if available)</td></tr>
<tr><td colspan=2 class="courier_left">    <a class="code" href="#applypre">void (*applyPreconditioner)<br>
&nbsp;&nbsp;       ( void *x,  void *y, int *blockSize, struct primme_params  *primme);</a></td></tr>
<tr><td colspan=2 class="courier_left">    // Matrix times a multivector for mass matrix B for generalized  Ax = xBl</td></tr>
<tr><td colspan=2 class="courier_left">    <a class="code" href="#massmatrix">void (*massMatrixMatvec)<br>
&nbsp;&nbsp;       ( void *x,  void *y, int *blockSize, struct primme_params  *primme);</a></td></tr>
<tr><td colspan=2 class="courier_left">    // input for the following is only required for parallel programs</td></tr>
<tr><td colspan=2 class="courier_left">    <a class="code" href="#numprocs">int numProcs;</a></td></tr>
<tr><td colspan=2 class="courier_left">    <a class="code" href="#procid">int procID;</a></td></tr>
<tr><td colspan=2 class="courier_left">    <a class="code" href="#nlocal">int nLocal;</a></td></tr>
<tr><td colspan=2 class="courier_left">    <a class="code" href="#comminfo">void *commInfo;</a></td></tr>
<tr><td colspan=2 class="courier_left">    <a class="code" href="#globalsum">void (*globalSumDouble)<br>
&nbsp;(void *sendBuf, void *recvBuf, int *count, struct  primme_params *primme);</a></td></tr>
<tr><td colspan=2 class="courier_left">    // Though primme_initialize will assign defaults, most users will  set these</td><?tr>
<tr><td colspan=2 class="courier_left">    <a class="code" href="#numevals">int numEvals;</a></td></tr>
<tr><td colspan=2 class="courier_left">    <a class="code" href="#primmetarget">primme_target target;</a></td></tr>
<tr><td colspan=2 class="courier_left">    <a class="code" href="#numtargetshifts">int numTargetShifts;</a>              // For targeting interior epairs,</td></tr>
<tr><td colspan=2 class="courier_left">    <a class="code" href="#targetshifts">double *targetShifts;</a>             // at least one shift must also  be set</td></tr>
<tr><td colspan=2 class="courier_left">    /* Printing and reporting */</td></tr>
<tr><td colspan=2 class="courier_left">    <a class="code" href="#outputfile">FILE *outputFile;</a></td></tr>
<tr><td colspan=2 class="courier_left">    <a class="code" href="#printlevel">int printLevel;</a></td></tr>
<tr><td colspan=2 class="courier_left">    /* the following will be given default values depending on the  method */</td></tr>
<tr><td colspan=2 class="courier_left">    <a class="code" href="#dynamicmethod">int dynamicMethodSwitch;</a></td></tr>
<tr><td colspan=2 class="courier_left">    <a class="code" href="#locking">int locking;</a></td></tr>
<tr><td colspan=2 class="courier_left">    <a class="code" href="#initsize">int initSize;</a></td></tr>
<tr><td colspan=2 class="courier_left">    <a class="code" href="numorthoconst">int numOrthoConst;</a></td></tr>
<tr><td colspan=2 class="courier_left">    <a class="code" href="#maxbasissize">int maxBasisSize;</a></td></tr>
<tr><td colspan=2 class="courier_left">    <a class="code" href="#minrestartsize">int minRestartSize;</a></td></tr>
<tr><td colspan=2 class="courier_left">    <a class="code" href="#maxblocksize">int maxBlockSize;</a></td></tr>
<tr><td colspan=2 class="courier_left">    <a class="code" href="#maxmatvecs">int maxMatvecs;</a></td></tr>
<tr><td colspan=2 class="courier_left">    <a class="code" href="#maxouteriterations"int maxOuterIterations;</a></td></tr>
<tr><td colspan=2 class="courier_left">    <a class="code" href="#intworksize">int intWorkSize;</a></td></tr>
<tr><td colspan=2 class="courier_left">    <a class="code" href="#realworksize">long int realWorkSize;</a></td></tr>
<tr><td colspan=2 class="courier_left">    <a class="code" href="#iseed">int iseed[4];</a></td></tr>
<tr><td colspan=2 class="courier_left">    <a class="code" href="#intwork">int *intWork;</a></td></tr>
<tr><td colspan=2 class="courier_left">    <a class="code" href="#realwork">void *realWork;</a></td></tr>
<tr><td colspan=2 class="courier_left">    <a class="code" href="#anorm">double aNorm;</a></td></tr>
<tr><td colspan=2 class="courier_left">    <a class="code" href="#eps">double eps;</a></td></tr>
<tr><td colspan=2 class="courier_left">    <a class="code" href="#matrix">void *matrix;</a></td></tr>
<tr><td colspan=2 class="courier_left">    <a class="code" href="#preconditioner">void *preconditioner;</a></td></tr>
<tr><td colspan=2 class="courier_left">    <a class="code" href="#shiftsforpreconditioner">double *ShiftsForPreconditioner;</a></td></tr>
<tr><td colspan=2 class="courier_left">    <a class="code" href="#restartingparams">struct restarting_params restartingParams;</a></td></tr>
<tr><td colspan=2 class="courier_left">    <a class="code" href="#correctionparams">struct correction_params correctionParams;</a></td></tr>
<tr><td colspan=2 class="courier_left">    <a class="code" href="#primmestats">struct primme_stats stats;</a></td></tr>
<tr><td colspan=2 class="courier_left">    <a class="code" href="#stacktrace">struct stackTraceNode *stackTrace;</a></td></tr>
<tr><td colspan=2 class="regular_courier">} primme_params;</td></tr>
</table>
<br>


<p class="breakhere"></p>
<a name="custom"></a>
<hr align="left" width="75%">
<h3>Customized parameter setting</h3>
<hr align="left" width="75%">
<p class="zero">
primme has the following members: (indicating also OUTPUT members)
</p>
<a name="cintn"></a>
	<hr align="center" width="50%" size="1%">
	<center>
	<p class="emphasis">The user must input at least the following arguments</p>
	</center>
	<hr align="center" width="50%" size="1%">
<br>
   <table><tr><td class="courier">
   int n;</td><td class="courier"> </td></tr>
   </table>
<p class="twenty_five">
   This is the dimension of the matrix.
</p>
<a name="matrixmatvec"></a>
<br>
   <table><tr><td class="courier">
   void (*matrixMatvec)<br>
   &nbsp;&nbsp;(void *x, void *y, int *blockSize, struct primme_params *primme);
         </td><td class="courier"> </td></tr>
   </table>
</p>
<p class="twenty_five">
   Block matrix-Multivector multiplication. y = A*x.
	x is one dimensional array containing the input blockSize vectors 
	packed one after the other, each of size primme.nLocal. 
	y contains the output blockSize vectors in the same fashion.
	BlockSize is by reference to facilitate a possible Fortran interface.
	x, y are void* arrays. Thus, the user must cast them before use:</p>
	<table align=center>
	<tr><td class="courier">xvec = (double *) x     for dprimme</td></tr>
	<tr><td class="courier">xvec = (Complex_Z *) x  for zprimme</td></tr>
	</table>
</p>
<a name="applypre"></a>
	<hr align="center" width="50%" size="1%">
	<center>
	<p class="emphasis">The following operators are for Preconditioning and <br>
       the Mass Matrix in generalized eigenproblems </p>
	</center>
	<hr align="center" width="50%" size="1%">
<br>
   <table><tr><td class="courier">
   void (*applyPreconditioner)<br>
   &nbsp;&nbsp;(void *x, void *y, int *blockSize, struct primme_params *primme);
</td><td class="courier"> </td></tr>
   </table>
	<p class="twenty_five">
Block preconditioner-multivector application. y = applyPreconditioner(x)
    BlockSize is by reference to facilitate a possible Fortran interface.
	x, y are void* arrays, that must be cast accordingly before use. </p>
	<p class="twenty_five"> If this preconditioner is to be used, set also 
	<a class="code" href="#correctionparams"> correctionParams.precondition </a> 
	to 1 </p>
<a name="massmatrix"></a>
<br>
   <table><tr><td class="courier">
void (*massMatrixMatvec)<br>
   &nbsp;&nbsp;(void *x, void *y, int *blockSize, struct primme_params *primme);</p>
         </td><td class="courier"> </td></tr>
   </table>

<p class="courier">
	<hr align="center" width="50%" size="1%">
	<center>
	<p class="emphasis">Generalized eigenproblems not implemented in current version
	 <br> This member is included for future compatibility</p>
	</center>
	<hr align="center" width="50%" size="1%">
	<p class="twenty_five">
   Block matrix-Multivector multiplication. y = B*x. B is the mass matrix 
	in generalized eigenvalue problems.
	BlockSize is by reference to facilitate a possible Fortran interface.
	x, y are void* arrays, that must be cast accordingly before use.</p>
<br>
<p class="breakhere"></p>
<a name="numprocs"></a>
	<hr align="center" width="50%" size="1%">
	<center>
	<p class="emphasis">Input for the following is only required for Parallel Programs</p>
	</center>
	<hr align="center" width="50%" size="1%">
<br>
   <table><tr><td class="courier">
   int numProcs;    [default = 1]
         </td><td class="courier"> </td></tr>
   </table>
<p class="twenty_five">
	&nbsp;&nbsp;Only needed if&nbsp;<font face="courier">pnumProcs == 1</font> to set the <font face="courier">nLocal</font> by default to n.<br>
	&nbsp;&nbsp;The user might possibly need this info in matvec or precond.</p>
<a name="procid"></a>
<br>
   <table><tr><td class="courier">
   int procID;      [default = 0]
         </td><td class="courier"> </td></tr>
   </table>
<p class="twenty_five">
	ProcessID. Only <font face="courier">procID == 0</font> prints information.</p>
<a name="nlocal"></a>
<br>
   <table><tr><td class="courier">
   int nLocal;
         </td><td class="courier"> </td></tr>
   </table>
<p class="twenty_five">
	Number of local rows on this processor. &nbsp;<font face="courier">nLocal = n</font> if sequential.</p>
<a name="comminfo"></a>
<br>
   <table><tr><td class="courier">
   void *commInfo;
         </td><td class="courier"> </td></tr>
   </table>
<p class="twenty_five">
	A pointer to whatever parallel environment structures needed.<br>
	For example, with MPI, it could be set to point to the MPI communicator.<br>
	PRIMME does not use this. It is available for possible use in <br>
	matrixMatvec, applyPreconditioner, massMatrixMatvec and globalSumDouble.
</p>
<a name="globalsum"></a>
<br>
   <table><tr><td class="courier">
   void (*globalSumDouble)(double *sendBuf, double *recvBuf,<br>
	&nbsp;&nbsp; int *count, primme_params *primme);
         </td><td class="courier"> </td></tr>
   </table>
<p class="twenty_five">
	Global sum function for parallel programs. No need to set for sequential.<br>
	recvBuf(i) = sum_over_all_processors( sendBuf(i) ), for all i=1,count<br>
	When MPI is used this is simply a wrapper to <tr> MPI_Allreduce() </tr><br>
	primme is needed only for primme->commInfo (eg, MPI communicator)<br>
	Count is by reference to facilitate a possible Fortran interface.<br>
	The data type is always double (even for zprimme).
</p>
<p class="breakhere"></p>
<a name="numevals"></a>
<p class="twenty_five">
	<hr align="center" width="50%" size="1%">
	<center>
	<p class="emphasis">primme_initialize will assign defaults for all the rest of parameters <br>
          Yet most users will set these:</p>
	</center>
	<hr align="center" width="50%" size="1%">
<br>
   <table><tr><td class="courier">
   int numEvals;</td><td class="courier">           [default = 1]</td></tr>
   </table>

	<table><tr><td>&nbsp;&nbsp;</td><td class="regular">
	Number of eigenvalues wanted<br>
	</td></tr></table>
<br>
<a name="primmetarget"></a>
   <table><tr><td class="courier">
   primme_target target</td><td class="courier">    [default = primme_smallest]</td></tr>
   </table>
<br>
	<table><tr><td>&nbsp;&nbsp;</td><td class="regular">
	Which eigenpairs to find.  target can can be any of the following enum:
	</td></tr></table>
<br>
	<table><tr><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td>
	<table>
        <tr><td align=left class="courier">primme_smallest</td><td align=left class="regularW">Smallest algebraic eigenvalues. Target shifts ignored</td></tr>
        <tr><td align=left class="courier">primme_largest     </td><td align=left class="regularW">Largest  algebraic eigenvalues. Target shifts ignored</td></tr>
        <tr><td align=left class="courier">primme_closest_geq </td><td align=left class="regularW">Closest to, but greater or equal than a set of shifts</td></tr>
        <tr><td align=left class="courier">primme_closest_leq </td><td align=left class="regularW">Closest to, but less or equal than a set of shifts</td></tr>
        <tr><td align=left class="courier">primme_closest_abs </td><td align=left class="regularW">Closest in absolute value to a set of shifts</td></tr>
	</table>
	</td></tr></table>
<br><br>
     <a name="numtargetshifts"></a>
     <table><tr><td class="courier">
     int numTargetShifts;</td><td class="courier">     [default = 0]</td></tr>
     </table>

	<table><tr><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td class="regular">
	Number of shifts around which interior eigenvalues <br>
        will be targeted. Used only when interior eigenvalues are saught.
	</td></tr></table>
<br>
  <a name="targetshifts"></a>
  <table><tr><td class="courier">
  double *targetShifts;</td><td class="courier">    [default = NULL]</td></tr>
  </table>
<br>
	<table><tr><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td class="regular">
	If numTargetShifts > 0, it should point to an array of shifts.<br>
        At least one shift is required.<br>
        Not used with primme_smallest or primme_largest.<br>
	<hr align="left" width="50%">
        Given shifts [tau1, tau2, ..., tauk] the code finds numEvals eigenpairs<br>
	according to the three modes as follows:       <br>
        Find e1 closest to tau1 AND geq/leq or closest in abs value to tau1<br>
        Find e2 closest to tau2 AND geq/leq or closest in abs value to tau2<br>
<br>
        Find e(k:numEvals) closest to tauk AND geq/leq/abs to tauk<br>
<br>   
        Notes:<br>
	<ul>
        <li class="list"> 
	For code efficiency and robustness, the shifts should be ordered.
        Order taus in ascending (descending) order <br>
	for shifts closer to the lower (higher) end of the spectrum.
        <li class="list"> When tau_k is closer to the lower end of the spectrum of A,
              primme_closest_leq is not very robust. <br>Use either geq or abs.
        <li class="list"> Similarly, for tau_k in the higher end of the spectrum,
              primme_closest_geq is not very robust. Use either leq or abs.
        <li class="list"> closest_leq and closest_geq are more efficient than closest_abs.
        <li class="list"> For interior eigenvalues use larger maxBasisSize than usual.
	</ul>
	<hr align="left" width="50%">
	</td></tr></table>
<p class="breakhere"></p>
   <a name="outputfile"></a>
	<hr align="center" width="50%" size="1%">
	<center>
	<p class="emphasis"> Printing and reporting </p>
	</center>
	<hr align="center" width="50%" size="1%">
   <table><tr><td class="courier">
   FILE *outputFile;</td><td class="courier">       [default = stdout]</td></tr>
   </table>

	<table><tr><td>&nbsp;&nbsp;</td><td class="regular">
	An optional output file that has been opened opened by the user.
	</td></tr></table>
 <br>
<a name="printlevel"></a>
   <table><tr><td class="courier">
   int printLevel;</td><td class="courier">    	   [default = 1]</td></tr>
   </table>
<p class="zero">	
	The level of message reporting from the code. </p>
	<table border=0>
	<tr><td class="regular">  0 </td><td  class="regular_left">silent</td></tr>
	<tr><td class="regular">  1  </td><td class="regular_left">print some error messages when these occur</td></tr>
	<tr><td class="regular">  2  </td><td class="regular_left">Level 1 AND info about targeted eigenpairs when they converge
			<br>
		       	#Converged $1 eval[ $2 ]= $3 norm $4 Mvecs $5 Time $7
			<br>
		  or with locking:<br>
		       	#Lock epair[ $1 ]= $3 norm $4 Mvecs $5 Time $7</td></tr>
	<tr><td class="regular">  3  </td><td class="regular_left">Level 2 AND info about targeted eigenpairs every outer iteration
			<br>
			OUT $6 conv $1 blk $8 MV $5 Sec $7 EV $3 |r| $4
			<br>
                Also, if method=DYNAMIC, show JDQMR/GDk ratio and current method </td></tr>
	<tr><td class="regular">  4  </td><td class="regular_left">Level 3 AND info about targeted eigenpairs every inner iteration
			<br>
			INN MV $5 Sec $7 Eval $3 Lin|r| $9 EV|r| $4</td></tr>
	<tr><td class="regular">  5  &nbsp;&nbsp;</td><td class="regular_left">Level 4 AND verbose info about certain choices of the 
	algorithm</td></tr>
	</table>
<br>
<p class="zero">
	    	   output key:
		   <table>
			<tr><td class="courier">$1: </td><td class="regular_left">num of converged pairs up to now</td></tr>
			<tr><td class="courier">$2: </td><td class="regular_left">The index of the pair currently converged</td></tr>
			<tr><td class="courier">$3: </td><td class="regular_left">The eigenvalue</td></tr>
			<tr><td class="courier">$4: </td><td class="regular_left">Its residual norm</td></tr>
			<tr><td class="courier">$5: </td><td class="regular_left">The current number of matvecs </td></tr>
			<tr><td class="courier">$6: </td><td class="regular_left">The current number of outer iterations</td></tr>
			<tr><td class="courier">$7: </td><td class="regular_left">The current elapsed time</td></tr>
			<tr><td class="courier">$8: </td><td class="regular_left">Index within the block of the targeted pair </td></tr>
			<tr><td class="courier">$9: </td><td class="regular_left">QMR norm of the linear system residual</td></tr>
		   </table></p>
<br>
	<table><tr><td class="regular">
	Convergence history for plotting may be produced simply by:</td></tr>
	<tr><td class="courier_left">grep OUT outpufile | awk '{print $8" "$14}' > out</td></tr>
	<tr><td class="courier_left">grep INN outpufile | awk '{print $3" "$11}' > inn</td></tr>
	<tr><td class="regular">Then in Matlab:</td></tr>
	   <tr><td class="courier_left">plot(out(:,1),out(:,2),'bo');hold; plot(inn(:,1),inn(:,2),'r');</td></tr>
	</table>
<br> 

	<b> Attention: </b> In parallel programs, printLevels 0 to 4 are only printed by procID = 0 <br>
	However, printLevel 5 is printed by all processors.
<br>
<br>
<br>


<a name="stacktrace"></a>
<table><tr><td class="courier">
   struct stackTraceNode *stackTrace;				(OUTPUT)
</td></tr></table>
<p class="twenty_five">
	Struct with the following members. If an error occurs the function<br>
	primme_PrintStackTrace(primme) prints the calling stack from top <br>
	to the function that caused the error. Nothing to set.
</p>
<p class="courier">
	int callingFunction;<br>
   	int failedFunction;<br>
   	int errorCode;<br>
   	int lineNumber;<br>
   	char fileName[PRIMME_MAX_NAME_LENGTH];<br>
   	struct stackTraceNode *nextNode;<br>
</p>
<br>
<p class="breakhere"></p>
<a name="anorm"></a>
	<hr align="center" width="50%" size="1%">
	<center>
	<p class="emphasis"> Convergence testing Thresholds </p>
	</center>
	<hr align="center" width="50%" size="1%">

   <table><tr><td class="courier">
   double aNorm;</td><td class="courier">           [default = 0.0]</td><td class="courier">			(OUTPUT)</td></tr>
   </table>
	
	<table><tr><td>&nbsp;&nbsp;</td><td>&nbsp;&nbsp;</td><td class="regular">
	An estimate of norm of the matrix A given by the user (usu Frobenious)<br>
<br>
        If aNorm  > 0.0, convergence tolerance = primme.eps * primme.aNorm<br>
                         &nbsp;&nbsp;&nbsp;(set aNorm = 1.0 to achieve exactly primme.eps)<br>
	If aNorm <= 0.0, convergence tolerance = <br>
			&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;primme.eps * Computed_Estimate_of_A_norm,<br>
          the Computed_Estimate_of_A_norm = largest absolute Ritz value seen<br>
          ON RETURN, aNorm also is replaced with the Computed_Estimate_of_A_norm
	</td></tr></table>
<br>
<a name="eps"></a>
   <table><tr><td class="courier">
   double eps;</td><td class="courier">             [default = 1e-12]</td></tr>
   </table>
	<table><tr><td>&nbsp;&nbsp;</td><td class="regular">
	Convergence is declared when the 2-norm of the residual satisfies:
	</td></tr></table>
<br>
	<table><tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td><td class="courier">
		||r|| < primme.eps * primme.aNorm
	</td></tr></table>
<p class="breakhere"></p>
	<hr align="center" width="50%" size="1%">
	<center>
	<p class="emphasis">The following will be given Default values depending on the method </p>
	</center>
	<hr align="center" width="50%" size="1%">
   <a name="dynamicmethod"></a>
   <table><tr><td class="courier">
   int dynamicMethodSwitch;</td><td class="courier"> [default = 0]</td><td class="courier">(OUTPUT)</td></tr>
   </table>

	<table><tr><td>&nbsp;&nbsp;</td><td class="regular">
	Setting the primme_method to DYNAMIC, sets dynamicMethodSwitch = 1 <br>
	PRIMME alternates dynamically between DEFAULT_MIN_TIME (JDQMR_ETol) <br>
 	and DEFAULT_MIN_MATVECS (GD+k), trying to identify the fastest method.<br><br>
	On exit, it holds a recommended method for future runs on this problem:<br>
	<table border=0>
        <tr><td class="dyncourier">   dynamicMethodSwitch = -1   </td><td class="regular_left_dynamic">use DEFAULT_MIN_MATVECS next time</td></tr>
        <tr><td class="dyncourier">   dynamicMethodSwitch = -2   </td><td class="regular_left_dynamic">use DEFAULT_MIN_TIME next time</td></tr>
        <tr><td class="dyncourier">   dynamicMethodSwitch = -3   </td><td class="regular_left_dynamic">Close call. Use again dynamic next time</td></tr>
	</table>
	</td></tr></table>
<br>
	<table><tr><td>&nbsp;&nbsp;</td><td class="regular">
	Even for expert users we do not recommend setting dynamicMethodSwitch<br>
	by hand, but only through primme_set_method(DYNAMIC).<br>
	We obtain timings by the gettimeofday Unix utility. If a cheaper, more<br>
	accurate timer is available, modify the &nbsp;<a href="PRIMMESRC/COMMONSRC/wtime.c">PRIMMESRC/COMMONSRC/wtime.c</a>
	</td></tr></table>
<br>
<a name="locking"></a>
   <table><tr><td class="courier">
   int locking;</td><td class="courier">							(OUTPUT)</td></tr>
   </table>

	<table><tr><td>&nbsp;&nbsp;</td><td class="regular">
	If set to 1, hard locking will be used (locking converged eigenvectors<br>
	out of the search basis). Otherwise the code will try to use soft<br>
	locking (a la ARPACK), when large enough minRestartSize is available.<br>
	</td></tr></table>
<br>
<a name="initsize"></a>	
   <table><tr><td class="courier">
   int initSize;</td><td class="courier">	   [default = 0]</td><td class="courier">	(OUTPUT)</td></tr>
   </table>

	<table><tr><td>&nbsp;&nbsp;</td><td class="regular">
	On INPUT, the number of initial guesses provided in evecs array.<br>
	ON OUTPUT, the number of converged eigenpairs.<br>
	DURING execution, holds the current number of converged eigenpairs.<br>
	If in addition locking is used, these are accessible in evals & evecs.
	</td></tr></table>
<br>
<a name="numorthoconst"></a>
   <table><tr><td class="courier">
   int numOrthoConst;</td><td class="courier">      [default = 0]</td></tr>
   </table>

	<table><tr><td>&nbsp;&nbsp;</td><td class="regular">
	Number of external orthogonalization constraints provided in the first <br>
	numOrthoConst vectors of evecs. THen eigenvectors are found orthogonal <br>
	to those constraints (equivalent to solving (I-YY')A(I-YY') for given Y)<br>
	This is a handy feature if some eigenvectors are already known, or <br>
	for finding some eigenvalues, exiting primme, and then calling it <br>
	again (possibly with different parameters) to find some more.
	</td></tr></table>
<br>
<a name="maxbasissize"></a>
   <table><tr><td class="courier">
   int maxBasisSize;	   </td></tr>
   </table>

	<table><tr><td>&nbsp;&nbsp;</td><td class="regular">
	The maximum basis size allowed in the main iteration. This has memory<br>
	implications. The default depends on method.
	</td></tr></table>
<br>
<a name="minrestartsize"></a>
   <table><tr><td class="courier">
   int minRestartSize;     </td></tr>
   </table>

	<table><tr><td>&nbsp;&nbsp;</td><td class="regular">
	The code will try to keep at least as many Ritz vectors every time <br>
	it needs to restart after the maxBasisSize has been reached.<br>
	The default depends on maxBasisSize, blockSize and method.
 	</td></tr></table>
<br>
<a name="maxblocksize"></a>
   <table><tr><td class="courier">
   int maxBlockSize;</td><td class="courier"> 	   [default = 1] </td></tr>
   </table>
	
	<table><tr><td>&nbsp;&nbsp;</td><td class="regular">
	The maximum block size the code will try to use. The user should set<br>
	this based on the architecture specifics of the target computer, <br>
	as well as any a priori knowledge of multiplicities. The code does <br>
	NOT require maxBlockSize > 1 to find multiple eigenvalues.  For some <br>
	methods, keeping maxBlockSize = 1 yields the best overall performance.<br>
	NOTE: Inner iterations of QMR are not performed in a block fashion.<br>
	Every correction equation from a block is solved independently.
	</td></tr></table>	
<br>
<a name="maxmatvecs"></a>
   <table><tr><td class="courier">
   int maxMatvecs;</td><td class="courier">         [default = INT_MAX]</td></tr>
   </table>

	<table><tr><td>&nbsp;&nbsp;</td><td class="regular">
	Maximum number of matrix vector multiplications (approximately 
	equal to the number <br>
	of preconditioning operations) that the code is allowed to 
	perform before it exits.
   	</td></tr></table>
<p class="breakhere"></p>
<a name="maxouteriterations"></a>	
   <table><tr><td class="courier">
   int maxOuterIterations;</td><td class="courier"> [default = INT_MAX]</td></tr>
   </table>
	<table><tr><td>&nbsp;&nbsp;</td><td class="regular">
	Maximum number of outer iterations that the code is allowed to perform <br>
	before it exits. NOTE: Currently we do not check this.
	</td></tr></table>
<br>
<a name="intworksize"></a>
   <table><tr><td class="courier">
   int intWorkSize;</td><td class="courier">						(INPUT/OUTPUT)</td></tr>
   </table>

	<table><tr><td>&nbsp;&nbsp;</td><td class="regular">
	Size of the integer work array IN BYTES. The user provides it if <br>
   	the user provides also the work array. After a call to dprimme/zprimme<br>
	with (NULL,NULL,NULL,&amp;primme), intWorkSize has the size of integer<br>
	workspace that will be required by the parameters set in primme.
 	</td></tr></table>
<br>
<a name="realworksize"></a>
   <table><tr><td class="courier">
   long int realWorkSize;</td><td class="courier">					(INPUT/OUTPUT)</td></tr>
   </table>

	<table><tr><td>&nbsp;&nbsp;</td><td class="regular">
	Size of the real/complex work array IN BYTES. The user provides it if <br>
	the user provides also the work array. After a call to dprimme/zprimme<br>
	with (NULL,NULL,NULL,&amp;primme), realWorkSize has the size of real<br>
	workspace that will be required by the parameters set in primme.
	</td></tr></table>
<br>
<a name="intwork"></a>
   <table><tr><td class="courier">
   int *intWork;</td><td class="courier">           [default = NULL]</td><td class="courier"> 			(INPUT/OUTPUT)</td></tr>
   </table>

	<table><tr><td>&nbsp;&nbsp;</td><td class="regular">
	pointer to an integer work array. If NULL, or if its size is not <br>
	sufficient, the code will free *intWork and allocate its own workspace <br>
        to match the space requirements of the requested method or the <br>
	primme parameters. <br>
        On output, the first element shows if a Locking problem has occurred.<br>
        Using locking for large numEvals may, in some rare cases, cause some pairs<br>
	to be practically converged, in the sense that their components are in the<br>
	basis of evecs. If intWork[0] == 1, and if required, a Rayleigh Ritz on <br>
	evecs will provide the accurate eigenvectors (see [4]).
	</td></tr></table>
<br>
<a name="realwork"></a>
   <table><tr><td class="courier">
   void *realWork;</td><td class="courier">  	   [default = NULL]</td><td class="courier">			(INPUT/OUTPUT)</td></tr>
   </table>

	<table><tr><td>&nbsp;&nbsp;</td><td class="regular">
	pointer to a void* work array. In ZPRIMME used both for Complex_Z and <br>
	double work. If not given, or if its size is not sufficient the code <br>
	will free *realWork and allocate its own workspace to match the space <br>
	requirements of the requested method or the primme parameters.
	</td></tr></table>
<br>
<a name="iseed"></a>
   <table><tr><td class="courier">
   int iseed[4];</td><td class="courier">   [default = (1 2 3 5)]</td></tr>
   </table>

	<table><tr><td>&nbsp;&nbsp;</td><td class="regular">
	The seeds needed by the Lapack d/zlarnv.f.
	</td></tr></table>
<br>
   <a name="matrix"><a>
   <table><tr><td class="courier">
   void *matrix;<br>
   <a name="preconditioner"></a>
   void *preconditioner;
   </td></tr></table>

	<table><tr><td>&nbsp;&nbsp;</td><td class="regular">
	Unused pointers that the user can use to pass any required information <br>
	in the matrix-vector and preconditioning operations. See test drivers.
	</table>

<br>
   <a name="shiftsforpreconditioner"></a>
   <table><tr><td class="courier">
   double *ShiftsForPreconditioner;
   </td></tr></table>

	<table><tr><td>&nbsp;&nbsp;</td><td class="regular">
	Array provided by d/zprimme() holding the shifts to be used (if needed)<br>
	in the preconditioning operation. For example if the block size is 3,<br>
	there will be an array of three shifts in ShiftsForPreconditioner.<br>
	Then the user can invert a shifted preconditioner for each of the <br>
	block vectors:<br>
		&nbsp;&nbsp;&nbsp;&nbsp;(M-ShiftsForPreconditioner[i])^{-1} v_i<br>
	Classical Davidson (diagonal) preconditioning is an example of this.
	</td></tr></table>

<p class="breakhere"></p>
   <a name="restartingparams"></a>
	<hr align="center" width="50%" size="1%">
	<center>
	<p class="emphasis">Restarting parameters </p>
	</center>
	<hr align="center" width="50%" size="1%">
   <table><tr><td class="courier">
   struct restarting_params restartingParams;
   </td></tr></table>

	<table><tr><td class="regular">&nbsp;&nbsp;
        stucture with the following members:
	</td></tr></table>
	
	<table><tr><td class="courier">
        &nbsp;primme_restartscheme scheme</td><td class="courier">  [default = primme_thick]</td></tr></table>
	   <table><tr><td class="regular">&nbsp;&nbsp;
	   	possible values are:<br>
	   	<table>
	 	<tr><td class="dyncourier">&nbsp;&nbsp;primme_thick&nbsp;&nbsp;</td>
		<td class="regular_left_dynamic">  
		Thick restarting. This is the most efficient and robust<br> in the general case.</td></tr>
		<tr><td class="dyncourier">&nbsp;&nbsp;primme_dtr</td><td class="regular_left_dynamic">	 
		Dynamic thick restarting. Helpful without <br>
		preconditioning but it is expensive to implement.</td></tr>
	   	</table>
	   	</td></tr>
	   </table>
<br>
	<table><tr><td class="courier">
        int maxPrevRetain</td><td class="courier"> 			[default = 1]</td></tr>
	</table>
		<table><tr><td>&nbsp;&nbsp;&nbsp;&nbsp;</td><td class="regular">
		number of approximations from previous iteration to be retained<br>
		after restart.  This is recurrence based restarting (see GD+1, <br>
		LOBPCG, etc). If maxPrevRetain > 0, then the restart size will <br>
		be:  minRestartSize + maxPrevRetain.
		</table>
<br>
<a name="primmestats"></a>
	<hr align="center" width="50%" size="1%">
	<center>
	<p class="emphasis">Convergence Statistics </p>
	</center>
	<hr align="center" width="50%" size="1%">
<table><tr><td class="courier">
   struct primme_stats stats; 					(OUTPUT)
   </td></tr></table>
<p class="twenty_five">
	Struct with the following members to report statistics back. <br>
	Nothing has to be set. Can be checked also during execution, <br>
	e.g., in the user provided Matvec or preconditioning function.
</p>
<p class="courier">
   	int numOuterIterations;<br>
   	int numRestarts;<br>
   	int numMatvecs;<br>
   	double elapsedTime;
</p>
<p class="breakhere"></p>
   <a name="correctionparams"></a>
	<hr align="center" width="50%" size="1%">
	<center>
	<p class="emphasis">Parameters for the correction equation </p>
	</center>
	<hr align="center" width="50%" size="1%">
   
   <table><tr><td class="courier">
   struct correction_params correctionParams;
   </td></tr></table>
	
   <p class="twenty_five">	
	structure with the following members:
   </p>
   <p class="courier">
	   int precondition;			[default = 0]
   </p>
   <p class="twenty_five">
		Set to 1 if preconditioning is to be performed. Make sure the 
		applyPreconditioner is not NULL then!
   </p>
   <p class="courier">

	   int robustShifts;
  </p>	
  <p class="twenty_five">
		Set to 1 to use robustShifting. It helps avoid stagnation and 
		missconvergence some times. 

<p class="courier">
	   int maxInnerIterations;
</p>
<p class="twenty_five">		Number of inner QMR iterations:
			<table>
                        <tr><td class="regular">&nbsp;&nbsp;&nbsp;&nbsp;= 0</td><td class="regular_left">   No inner iterations (GD/JD)</td></tr>
                        <tr><td class="regular">&nbsp;&nbsp;&nbsp;&nbsp;= k</td><td class="regular_left">   Perform at most k inner iterations per outer step<br>
                              (or if convergence < tol)</td></tr>
                        <tr><td class="regular">&nbsp;&nbsp;&nbsp;&nbsp;< 0</td><td class="regular_left">  Perform at most the rest of allowed matvecs<br>
                                  primme.maxMatvecs - primme.stats.numMatvecs<br>
                              so basically do not stop by number of iterations.</td></tr>
			</table>
</p>
<p class="courier">
	   double relTolBase;
</p>
<p class="twenty_five">

		This is a legacy from classical JDQR. Inner QMR is iterated 
		until linear system residual < relTolBase^(-OuterIterations).
		We recommend STRONGLY against its use.
</p>
<p class="courier">
	   primme_convergencetest convTest;
</p>
<p class="twenty_five">	
		How to stop the inner QMR method.
		<table>
        	<tr><td class="courier_leftnw">= primme_full_LTolerance</td><td class="regular">        // stop by iterations only</td></tr>
        	<tr><td class="courier_leftnw">= primme_decreasing_LTolerance</td><td class="regular"> // LinSysResidual < <br>
						// relTolBase^(-outerIterations)</td></tr>
        	<tr><td class="courier_leftnw">= primme_adaptive</td><td class="regular">               // JDQMR adaptive (like <br>
						//	        Notay's JDCG)</td></tr>
        	<tr><td class="courier_leftnw">= primme_adaptive_ETolerance</td><td class="regular">    // as in JDQMR adaptive but <br>
					        // stop also when<br>
					     // Eres_(innerIts) < Eres_(0) * 0.1</td></tr>
		</table>
<p class="twenty_five">
		The last scheme simply stops inner iterations when 1 order of 
		magnitude has been achieved for the eigenresidual (NOT the 
		linear system residual)</p>
</p>	
<p class="courier">
	   struct JD_projectors projectors;
</p>
<p class="twenty_five">		Set the following to 1:</p>
		<table>
   		<tr><td class="courier_leftnw">int LeftQ;&nbsp;&nbsp;</td><td class="regular">    if a projector with Q must be applied on the left</td></tr>
   		<tr><td class="courier_leftnw">int LeftX;</td><td class="regular">    if a projector with X must be applied on the left</td></tr>
   		<tr><td class="courier_leftnw">int RightQ;</td><td class="regular">   if a projector with Q must be applied on the right</td></tr>
   		<tr><Td class="courier_leftnw">int RightX;</td><td class="regular">   if a projector with X must be applied on the right</td></tr>
   		<tr><td class="courier_leftnw">int SkewQ;</td><td class="regular">    if the Q right projector must be skew</td></tr>
   		<tr><td class="courier_leftnw">int SkewX;</td><td class="regular">    if the X right projector must be skew</td></tr>
		</table>
<br><br>
	   <table>	
	   <tr>
 	   <td><u>(I-QQ')</u></td><td><u>(I-xx')</u></td><td>(A-shift I)</td><td><u>(I-Kx(x'Kx)^(-1)x')</u></td><td><u>(I-KQ(Q'K Q)^(-1)Q')</u></td><Td> K </td></tr>
	   <tr><td align=center>Lq</td><td align=center>Lx</td><td>&nbsp;</td><td align=center>Rx  Sx</td><td align=center>Rq Sq</td></tr>
	   </table>
	<p class="normal">
  	   see <font face="courier">setup_JD_projectors()</font> in inner_solve.c for more information.
	</p>

	<hr align="center" width="50%" size="1%">
	<center>
	<p class="emphasis">Some notes on the inner QMR convergence tests: </p>
	</center>
	<hr align="center" width="50%" size="1%">

<p class="twenty_five">
	The following two tests could be combined in all possible ways.
<br>
  Eg: maxInnerIterations  convTest
</p>
	<table>
	<tr><td class="courier">0</td><td class="regular_left">-</td><td class="regular_left">GD/JD</td></tr>
	<tr><td class="courier">k</td><td class="regular_left">full_LTolerance</td><td class="regular_left">JDQR always k</td></tr>
	<tr><td class="courier">k</td><td class="regular_left">decreasingTolerance</td><td class="regular_left">JDQR With Steinhaug(k)</td></tr>
	<tr><td class="courier">k</td><td  class="regular_left">adaptive</td><td class="regular_left">JDQMR( but no more than k)</td></tr>
	<tr><td class="courier">< 0</td><td class="regular_left">full_LTolerance</td><td class="regular_left">Makes no sense! DO NOT DO!</td></tr>
	<tr><td class="courier">< 0</td><td class="regular_left">decreasingTolerance</td><td class="regular_left">JDQR With Steinhaug</td></tr>
	<tr><td class="courier">< 0</td><td class="regular_left">adaptive</td><td class="regular_left">JDQMR</td></tr>
	<tr><td class="courier">< 0</td><td class="regular_left">adaptive_ETol</td><td class="regular_left">JDQMR with only 1 order improvement</td></tr>
	</table>
			etc...
<br>
<br>
<p class="twenty_five">
  Choice of GD projectors:
	<table>			
	 <tr><td colspan=2 class="courier">(I - (Kinv*x) x') </td><td colspan=2 class="courier">(I - (Kinv*Q) Q') Kinv*r</td><td class="courier"></td></tr>
	 <tr><td class="courier">RitzR, </td><Td class="courier">RitzSkew</td><td class="courier">   EvecR, </td><Td class="courier">EvecSkew</td><td></td></tr>
	 <tr><td align=center class="courier">  1 </td><td align=center class="courier">       1 </td><td align=center class="courier">       1 </td><td align=center class="courier">      1 </td><td class="regular">      (this is almost never done)</td></tr>
	 <tr><td align=center class="courier">  1 </td><td align=center class="courier">       1 </td><td align=center class="courier">       0 </td><td align=center class="courier">      0   </td><td class="regular">    Olsen's</td></tr>
	 <tr><td align=center class="courier">  1 </td><td align=center class="courier">       0 </td><td align=center class="courier">       0 </td><td align=center class="courier">      0  </td><td class="regular">     Unnecessary. Ortho follows.</td></tr>
	 <tr><Td align=center class="courier">  0 </td><td align=center class="courier">       1  </td><td align=center class="courier">      0  </td><td align=center class="courier">     0  </td><Td class="regular">     Does not exist</td></tr>
	 <tr><td align=center class="courier">  0 </td><td align=center class="courier">       0 </td><td align=center class="courier">       0 </td><td align=center class="courier">      0  </td><Td class="regular">     GD</td></tr>
	 <tr><td align=center class="courier">  0 </td><td align=center class="courier">       0 </td><td align=center class="courier">       </td><Td></td><td class="regular">        approximate Olsen: Kinv(r-err*x)</td></tr>
  	</table>
</p>
<br>
<p class="twenty_five">
  Choice of JD projectors:
	<br>
	<table>
	<tr><td class="courier">(I-QQ')</td><Td class="courier">(I-xx')</td><td class="courier">(A-sI)</td><td colspan=2 class="courier"> (I - (Kinv*x) x')</td><td colspan=2 class="courier">(I - (Kinv*Q) Q') Kinv*r</td></tr>
	<tr><td align=center class="courier">EvecL</td><td class="courier">  RitzL </td><td>&nbsp;</td><td class="courier">        RitzR,</td><td class="courier"> RitzSkew</td><td class="courier">   EvecR,</td><td class="courier"> EvecSkew</td></tr>
	<tr><td align=center class="courier">   1 </td><td align=center class="courier">      1 </td><td>&nbsp;</td><td align=center class="courier">              1 </td><td align=center class="courier">      1  </td><td align=center class="courier">       1 </td><td align=center class="courier">      1 </td></tr>
	<tr><td align=center class="courier">   1 </td><td align=center class="courier">      1 </td><td>&nbsp;</td><td align=center class="courier">              1 </td><td align=center class="courier">      0  </td><td align=center class="courier">       1 </td><td align=center class="courier">      0 </td></tr>
	<tr><td align=center class="courier">   1 </td><td align=center class="courier">      1 </td><td>&nbsp;</td><td align=center class="courier">              1 </td><td align=center class="courier">      1  </td><td align=center class="courier">       1 </td><td align=center class="courier">      0 </td></tr>
	<tr><td align=center class="courier">   1 </td><td align=center class="courier">      1 </td><td>&nbsp;</td><td align=center class="courier">              1 </td><td align=center class="courier">      0  </td><td align=center class="courier">       1 </td><td align=center class="courier">      1  </td><td>meaningless</td></tr></table> 
</p>
			...
<br>

<p class="breakhere"></p>
<a name="fortran"></a>
<hr align="left" width="75%">
<h3>Fortran Library Interface</h3>
<hr align="left" width="75%">
<p class="zero">
The following functions are available for users to call from FORTRAN.<br>
Notice the appendix _f77.
</p>

<p class="courier">
      call dprimme_f77(double *evals, double *evecs, double *rnorms,
	  	    primme_params **primme, int *ierr);
</p>

<p class="courier">
      call zprimme_f77(double *evals, Complex_Z *evecs, double *rnorms,
	  	    primme_params **primme, int *ierr);
</p>
<p class="courier">
      call primme_initialize_f77(primme_params **primme);
</p>
<p class="courier">
      call primme_free_f77(primme_params **primme);
</p>
<p class="courier">
      call primme_display_params_f77(primme_params **primme);
</p>
<p class="courier">
      call primme_printstacktrace_f77(primme_params **primme);
</p>
<p class="courier">
      call primme_set_method_f77(primme_params **primme, int *method,int *ierr);
</p>
<p class="courier">
      call primme_set_member_f77(primme_params **primme, int *label, void *ptr);
</p>
<p class="courier">
      call primme_get_prec_shift_f77(primme_params *primme, int *i, 
				     double *shift);
</p>
<p class="courier">
      call primme_get_member_f77(primme_params *primme, int *label, void *ptr);
</p>
<p class="courier">
      call primmetop_get_member_f77(primme_params **primme, int *label, 
				    void *ptr);
</p>
<p class="courier">
      call primmetop_get_prec_shift_f77(primme_params **primme, int *i, 
 				        double *shift);
</p>

<a name="fortranrunning"></a>
<hr align="left" width="75%">
<h3>Running From Fortran</h3>
<hr align="left" width="75%">
<p class="zero">
To call d/zprimme from Fortran, look at (D)ZTEST/driver_f77seq.c. 
Basic steps:
</p>

<hr align="left" width="50%">
<p class="courier">
* Include "primme_f77.h"<br>
* initialize a primme structure for default settings:
<br><br>
      integer primme &nbsp
  (or integer*8 primme if running on a 64 bit operating system)<br>
<br>
      call primme_initialize_f77(primme)
</p>
<hr align="left" width="50%">
<p class="zero">
Then, set the various structure members and possibly the method to be used. 
Individual primme members can be set by calling:
</p>
<p class="courier">
      call primme_set_member_f77(primme, MEMBER_LABEL, variable)
</p>
<p class="twenty_five">
   where
   	MEMBER_LABEL is the name of the primme member prepended with PRIMMEF77_
	and replacing all dots (.) with underscores (_). See primme_f77.h
    	Eg.:
</p>
<p class="courier">		
 call primme_set_member_f77(primme, PRIMMEF77_correctionParams_precondition, 1)
</p>
<p class="twenty_five">
	sets the primme->correctionParams.precondition = 1 </p>
<br>
<p class="zero">
Matrix-vector and preconditioning fortran function must be declared
external and passed in the same way to primme:</p>
<p class="courier">
<br>
      external MV<br>
 	...<br>
      call primme_set_member_f77(primme, PRIMMEF77_matrixMatvec, MV)<br>
</p>
<br><br><br>
<hr align="left" width="50%">
A preset method is chosen in a similar way:
<br>
<p class="courier">
      call primme_set_method_f77(primme, METHOD, RealMem)</p>
<br>
<p class="twenty_five">
   where
	METHOD has the name of the preset method as above, prepended 
	by PRIMMEF77_  All these are defined in primme_f77. 
</p>
<p class="courier">
      call primme_set_method_f77(primme, PRIMMEF77_JDQMR_ETol, ierr)
</p>
<br>
<hr align="left" width="50%">
<p class="zero">
Then call dprimme:</p>
<p class="courier">
      call dprimme_f77(evals, evecs, rnorms, primme, ierr)
</p>
<hr align="left" width="50%">
<p class="zero">
How to obtain the value of a member of the PRIMME structure depends
on whether it is called from an F77 subroutine called directly by the driver, 
or by an F77 function invoked by PRIMME (such as matrixMatvec, 
applyPreconditioner, massMatrixMatvec or globalSumDouble)
</p>
<p class="twenty_five">
 From the driver: primme is really: primme_params **primme
</p>
<p class="courier">
      call primmetop_get_member_f77(primme, MEMBER_LABEL, ResultVariable)
</p>
<p class="twenty_five">
 From matrixMatvec, applyPreconditioner, massMatrixMatvec and globalSumDouble: 
 primme is really: primme_params *primme, so a different function must be used: 
</p>
<p class="courier">
      call primme_get_member_f77(primme, MEMBER_LABEL, ResultVariable)
</p>
<hr align="left" width="50%">
<p class="zero">
In preconditioning, a PRIMME provided shift may be used. Assuming a block
of blockSize, from which the i-th shift is needed, i = 1,2,3...,blockSize
the user can call from inside the f77 applyPreconditioner() the following 
function:
</p>
<p class="courier">
      call primme_get_prec_shift_f77(primme, i, shift)
</p>
<hr align="left" width="50%">
<p class="breakhere"></p>
<a name="errors"></a>
<hr align="left" width="75%">
<h3>List of error codes returned by dprimme() / zprimme()</h3>
<hr align="left" width="75%">
<p class="zero">
These can be found also in &nbsp;<a href="PRIMMESRC/DSRC/primme_d.c">primme_d.c</a>
                              or <a href="PRIMMESRC/ZSRC/primme_z.c">primme_z.c</a>
</p>

<table border=0>
<tr><td class="courier_right">   0: </td><td class="regular_left">Success</td></tr>
<tr><td class="courier_right">   1: </td><td class="regular_left">Reporting only amount of required memory</td></tr>
<tr><td class="courier_right">  -1: </td><td class="regular_left">Failure to allocate int or real workspace</td></tr>
<tr><td class="courier_right">  -2: </td><td class="regular_left">Malloc failure in allocating a permutation integer 
array</td></tr>
<tr><td class="courier_right">  -3: </td><td class="regular_left">main_iter() encountered problem. PRIMME has printed 
in STDERR 
the 
	calling stack of the functions where the error occured</td></tr>
<tr><td class="courier_right">  -4: </td><td class="regular_left">if (primme == NULL)</td></tr>
<tr><td class="courier_right">  -5: </td><td class="regular_left">if (primme->n <= 0 || primme->nLocal <= 0)</td></tr>
<tr><td class="courier_right">  -6: </td><td class="regular_left">if (primme->numProcs < 1)</td></tr>
<tr><td class="courier_right">  -7: </td><td class="regular_left">if (primme->matrixMatvec == NULL)</td></tr>
<tr><td class="courier_right">  -8: </td><td class="regular_left">if (primme->applyPreconditioner == NULL && 
	  primme->correctionParams.precondition )</td></tr>
<tr><td class="courier_right">  -9: </td><td class="regular_left">if (primme->globalSumDouble == NULL)</td></tr>
<tr><td class="courier_right">  -10:</td><td class="regular_left">if (primme->numEvals > primme->n)</td></tr>
<tr><td class="courier_right">  -11:</td><td class="regular_left">if (primme->numEvals < 0)</td></tr>
<tr><td class="courier_right">  -12:</td><td class="regular_left">if (primme->eps > 0.0L && primme->eps < machine 
precision</td></tr>
<tr><td class="courier_right">  -13:</td><td class="regular_left"> if (primme->target not properly defined)</td></tr>
<tr><td class="courier_right">  -14:</td><td class="regular_left">if (primme->target == primme_closest_geq/leq/abs 
(interior 
needed)
                        && primme->numTargetShifts <= 0 (no shifts)</td></tr>
<tr><td class="courier_right">  -15:</td><td class="regular_left">if (primme->target == primme_closest_geq/leq/abs 
(interior 
needed)
                      && (primme->targetShifts == NULL  (no shifts array)</td></tr>
<tr><td class="courier_right">  -16:</td><td class="regular_left">if (primme->numOrthoConst < 0 || 
   	   primme->numOrthoConst >=primme->n   (no free dimensions left)</td></tr>
<tr><td class="courier_right">  -17:</td><td class="regular_left">if (primme->maxBasisSize < 2)</td></tr>
<tr><td class="courier_right">  -18:</td><td class="regular_left">if (primme->minRestartSize <= 0)</td></tr>
<tr><td class="courier_right">  -19:</td><td class="regular_left">if (primme->maxBlockSize <= 0)</td></tr>
<tr><td class="courier_right">  -20:</td><td class="regular_left">if (primme->restartingParams.maxPrevRetain < 
0)</td></tr>
<tr><td class="courier_right">  -21:</td><td class="regular_left">if (primme->restartingParams.scheme != primme_thick 
or 
primme_dtr)</td></tr>
<tr><td class="courier_right">  -22:</td><td class="regular_left">if (primme->initSize < 0)</td></tr>
<tr><td class="courier_right">  -23:</td><td class="regular_left">if (!primme->locking && primme->initSize > 
primme->maxBasisSize)</td></tr>
<tr><td class="courier_right">  -24:</td><td class="regular_left">if (primme->locking && primme->initSize > 
primme->numEvals)</td></tr>
<tr><td class="courier_right">  -25:</td><td class="regular_left">if (primme->restartingParams.maxPrevRetain +
          primme->minRestartSize >= primme->maxBasisSize)</td></tr>
<tr><td class="courier_right">  -26:</td><td class="regular_left">if (primme->minRestartSize >= primme->n)</td></tr>
<tr><td class="courier_right">  -27:</td><td class="regular_left">if (primme->printLevel < 0 || primme->printLevel > 
5)</td></tr>
<tr><td class="courier_right">  -28:</td><td class="regular_left">if (primme->correctionParams.convTest is not one of 
the<br>
		primme_full_LTolerance, primme_decreasing_LTolerance,<br>
       		primme_adaptive_ETolerance, primme_adaptive )</td></tr>
<tr><td class="courier_right">  -29:</td><td class="regular_left">if (primme->correctionParams.convTest == 
primme_decreasing_LTolerance 
<br>
	 primme->correctionParams.relTolBase <= 1.0L )</td></tr>
<tr><td class="courier_right">  -30:</td><td class="regular_left">if evals == NULL    (but not all evecs, evals and 
resNorms)</td></tr>
<tr><td class="courier_right">  -31:</td><td class="regular_left">if evecs == NULL    (but not all evecs, evals and 
resNorms)</td></tr>
<tr><td class="courier_right">  -32:</td><td class="regular_left">if resNorms == NULL (but not all evecs, evals and 
resNorms)</td></tr>
</table>
<br> <br> <br> <br> <br>
<table><tr><td class="ack">HTML Prepared By: Kim Berry</td></tr></table>
</body>
</html>


